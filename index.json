[{"content":"\u003cp\u003eThis article outlines how I implemented a Jira-based work tracking system in technical writing workflows.\u003c/p\u003e\n\u003cp\u003eIn the fast-paced realm of technical writing, effective collaboration with diverse stakeholders is vital for delivering high-quality documentation. To optimize our communication and boost transparency, I introduced a system using Jira as our work tracker. This innovative approach has significantly streamlined our workflow, addressing various challenges encountered during the process.\u003c/p\u003e\n\u003ch2 id=\"challenges\"\u003eChallenges\u003c/h2\u003e\n\u003cp\u003eDuring my work, I encountered several challenges in collaborating with stakeholders as follow:\u003c/p\u003e\n\u003ch4 id=\"frequent-status-inquiries\"\u003eFrequent Status Inquiries\u003c/h4\u003e\n\u003cp\u003eStakeholders, including product managers, developers, and support teams, often sought updates on document progress, including details such as links to documents in different environments and release status. This constant exchange of information created inefficiencies and consumed valuable time.\u003c/p\u003e\n\u003ch4 id=\"inconsistent-input\"\u003eInconsistent Input\u003c/h4\u003e\n\u003cp\u003eStakeholders provided input that underwent subsequent changes, introducing confusion and leading to delayed responses on the writer\u0026rsquo;s end.\u003c/p\u003e\n\u003ch4 id=\"post-tracking-issues\"\u003ePost-Tracking Issues\u003c/h4\u003e\n\u003cp\u003eTracing back the origin of specific pieces of information became challenging after the documentation was completed, contributing to potential confusion and misunderstandings.\u003c/p\u003e\n\u003ch4 id=\"unclear-release-signals\"\u003eUnclear Release Signals\u003c/h4\u003e\n\u003cp\u003eAmbiguity surrounding when to publish completed content caused delays and uncertainty in the release process.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eTo address these challenges, I organized a meeting with stakeholders to present the benefits of using Jira. During this session, I provided detailed instructions on how to use Jira and successfully garnered alignment for adopting this approach.\u003c/p\u003e\n\u003cp\u003eThe ticket template consists of the following information:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProduct/project name\u003c/li\u003e\n\u003cli\u003eRelease version\u003c/li\u003e\n\u003cli\u003eRelease date\u003c/li\u003e\n\u003cli\u003eRelease signal by product owner\u003c/li\u003e\n\u003cli\u003eConversation around the doc if any\u003c/li\u003e\n\u003cli\u003eDoc tracker fields as follows:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e| Document Title | Input** | Status** | Doc Link** |  \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e**Input refers to the sources that SMEs provide to the writer, such as Git PR, SNS conversation, Jira ticket, etc.\u003c/p\u003e\n\u003cp\u003e**There are six statuses: waiting for input, draft, in tech review, in language review, ready for release, and released.\u003c/p\u003e\n\u003cp\u003e**Use preview links when the document is ready for release and replace them with production links when the document is released.\u003c/p\u003e\n\u003ch2 id=\"results\"\u003eResults\u003c/h2\u003e\n\u003cp\u003eFollowing the implementation, I conducted a retrospective to assess the impact of incorporating Jira into our documentation processes:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eBefore (Without Jira)\u003c/th\u003e\n\u003cth\u003eAfter (With Jira)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eStakeholders sought updates, causing inefficiencies.\u003c/td\u003e\n\u003ctd\u003eTransparent progress tracking in Jira reduces inquiries.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eInconsistent stakeholder input led to confusion.\u003c/td\u003e\n\u003ctd\u003eJira formalizes input processes, minimizing confusion.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eTracing back information origin was challenging.\u003c/td\u003e\n\u003ctd\u003eJira serves as a record-keeping tool, aiding issue resolution.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmbiguity about when to publish content caused delays.\u003c/td\u003e\n\u003ctd\u003eJira formalizes the sign-off process, providing clarity.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eIn conclusion, adopting Jira as a work tracker has significantly enhanced our collaborative processes, bringing transparency, efficiency, and clarity to our documentation workflow. This structured approach has proven to be a valuable asset in our efforts to deliver timely and accurate technical content.\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://miumiu-op.github.io/blogs/sample3-tracker/","title":"Jira as Work Tracker"},{"content":"\u003cp\u003eThis article delves into my process of writing a user guide for a complext product.\u003c/p\u003e\n\u003cp\u003eI was assigned to write a guide that aims to introduce two tools designed for scheduling and managing background jobs within a Human Resource solution. The focus of this documentation is to provide comprehensive guidance for users engaging with these tools, catering to both provisioning and administrative environments.\u003c/p\u003e\n\u003ch2 id=\"writing-approach\"\u003eWriting Approach\u003c/h2\u003e\n\u003cp\u003eWhile composing the user guide, my writing approach is primarily focused on:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUser-Centricity\u003c/strong\u003e: Personally using the tool to ensure document content aligns with real users\u0026rsquo; needs and expectations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSystematic Coverage\u003c/strong\u003e: Collaborating with the product manager and customer support to understand features and functionalities from an overall perspective ensures comprehensive documentation.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eClarity\u003c/strong\u003e: Utilizing clear and concise language, complemented by visuals and examples for user-friendly comprehension.\u003c/p\u003e\n\u003ch2 id=\"challenges-encountered-and-solutions\"\u003eChallenges Encountered and Solutions\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eChallenges\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhile these tools share the same fundamental purpose, there exist gaps in their specific functionalities, influenced not only by user permissions between provisioners and administrators, but also by the development timeline. Untangling this intricate relationship and crafting documentation that resonated with both audiences posed a considerable challenge.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSolution\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAddressing the developmental disparities between Tool A and Tool B, I initiated extensive discussions with various stakeholders, including product managers and documentation architects. Upon reaching a consensus, I meticulously adjusted the documentation structure at both the overall document (directory) and individual document levels.\u003c/p\u003e\n\u003cp\u003eThis proactive effort ensures a clear separation between the two tools, with explicit indications of the tool type and required user permissions, aiming to eliminate any potential confusion for users.\u003c/p\u003e\n\u003cp\u003eFurthermore, I adopt a proactive approach to keep the documentation synchronized with ongoing product iterations and future roadmaps, facilitating timely updates based on evolving features and functionalities.\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://miumiu-op.github.io/blogs/sample1-guide/","title":"User Guide for Complex Product"},{"content":"\u003cp\u003eThis article is about how I\u0026rsquo;ve crafted Python scripts as part of a meticulous document migration effort.\u003c/p\u003e\n\u003cp\u003eAs part of a comprehensive document migration initiative, I\u0026rsquo;ve developed a suite of Python scripts tailored to ensure the seamless transition of documentation from an older system to a new platform. The primary goal is to perform meticulous syntax checks and modifications to prevent errors and maintain document integrity in the new environment.\u003c/p\u003e\n\u003ch2 id=\"script-descriptions\"\u003eScript Descriptions\u003c/h2\u003e\n\u003cp\u003eThe script comprises three components, each addressing the three most prevalent challenges encountered during documentation migration:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eTool Name\u003c/th\u003e\n\u003cth\u003ePurpose\u003c/th\u003e\n\u003cth\u003eKey Features\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eTag Checker\u003c/td\u003e\n\u003ctd\u003eValidates the structure of HTML or XML-like files, ensuring correct tag pairing.\u003c/td\u003e\n\u003ctd\u003eError reporting with detailed messages to aid in identifying formatting issues.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eQuote Checker\u003c/td\u003e\n\u003ctd\u003eAnalyzes text files to verify the proper pairing of single and double quotation marks.\u003c/td\u003e\n\u003ctd\u003eDetection of unclosed or mismatched quotes, accompanied by error reports indicating line numbers and positions.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVariable Usage Checker\u003c/td\u003e\n\u003ctd\u003eEnsures the correct usage of variables in code files, focusing on imports and definitions.\u003c/td\u003e\n\u003ctd\u003eIdentifies variables following a specific pattern, validates imports, and checks variable definitions.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThese scripts reflect my dedication to ensuring the accuracy and consistency of documentation, aligning with the best practices of the new document management system. Their collective usage guarantees a smooth and error-free transition, reinforcing the reliability of the migrated documentation.\u003c/p\u003e\n\u003ch2 id=\"code-sample\"\u003eCode Sample\u003c/h2\u003e\n\u003cdetails\u003e\n  \u003csummary\u003eExpand/Collapse\u003c/summary\u003e\n    \u003cpre\u003e\n\u003ccode class=\"language-python\"\u003e\nimport re\nimport os\n\u003cp\u003edef check_tag_pairs(file_path):\nstack = []\nwith open(file_path, \u0026lsquo;r\u0026rsquo;) as file:\nfor line_num, line in enumerate(file, start=1):\ntags = re.findall(r\u0026rsquo;\u0026lt;(\\w+)(?:\\s+\\w+=\u0026quot;.\u003cem\u003e?\u0026quot;)\u003c/em\u003e\\s*/?\u0026gt;|\u0026lt;/(\\w+)\u0026gt;\u0026rsquo;, line)\nfor start_tag, end_tag in tags:\nif start_tag and start_tag != \u0026lsquo;Set\u0026rsquo;:\nstack.append((start_tag, line_num))\nelif end_tag:\nif not stack:\nprint(f\u0026quot;Error: Found closing tag without corresponding opening tag at line {line_num}\u0026quot;)\nelse:\nwhile stack:\nlast_start_tag, _ = stack[-1]\nif last_start_tag == end_tag:\nstack.pop()\nbreak\nelse:\nprint(f\u0026quot;Error: Found closing tag \u0026lt;/{end_tag}\u0026gt; without corresponding opening tag at line {line_num}\u0026quot;)\nstack.pop()\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhile stack:\n    tag, line_num = stack.pop()\n    print(f\u0026quot;Error: Found unclosed tag \u0026lt;{tag}\u0026gt; at line {line_num}\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edef check_quotes(file_path):\nwith open(file_path, \u0026lsquo;r\u0026rsquo;) as file:\nline_num = 0\nsingle_quotes_stack = []\ndouble_quotes_stack = []\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    for line in file:\n        line_num += 1\n        index = 0\n\n        while index \u0026lt; len(line):\n            if line[index] == \u0026quot;'\u0026quot;:\n                if not single_quotes_stack or single_quotes_stack[-1][0] != line_num:\n                    single_quotes_stack.append((line_num, index + 1))\n                else:\n                    single_quotes_stack.pop()\n            elif line[index] == '\u0026quot;':\n                if not double_quotes_stack or double_quotes_stack[-1][0] != line_num:\n                    double_quotes_stack.append((line_num, index + 1))\n                else:\n                    double_quotes_stack.pop()\n\n            index += 1\n\n    if single_quotes_stack:\n        for line_num, quote_pos in single_quotes_stack:\n            print(f\u0026quot;Error: Found unclosed single quote at line {line_num}, position {quote_pos}\u0026quot;)\n\n    if double_quotes_stack:\n        for line_num, quote_pos in double_quotes_stack:\n            print(f\u0026quot;Error: Found unclosed double quote at line {line_num}, position {quote_pos}\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edef search_variable_usage(file_a_path):\nwith open(file_a_path, \u0026lsquo;r\u0026rsquo;) as file_a:\na_content = file_a.read()\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evariable_pattern = r'{([a-zA-Z]+\\.[a-zA-Z]+)\\[frontMatter\\.ag_platform\\]}'\nvariable_matches = re.findall(variable_pattern, a_content)\n\nfor variable in variable_matches:\n    import_pattern = rf'import \\* as ({variable.split(\u0026quot;.\u0026quot;)[0]}) from \\'(.+?)\\''\n    import_match = re.search(import_pattern, a_content)\n\n    if import_match:\n        import_path = import_match.group(2)\n\n        script_directory = os.path.dirname(os.path.abspath(__file__))\n        actual_file_path = get_actual_file_path(import_path, script_directory)\n\n        if not actual_file_path:\n            print(\u0026quot;Incorrect import statement format\u0026quot;)\n\n        if os.path.isfile(actual_file_path):\n            with open(actual_file_path, 'r') as import_file:\n                import_content = import_file.read()\n\n            export_pattern = rf'export const {variable.split(\u0026quot;.\u0026quot;)[1]}'\n            if not re.search(export_pattern, import_content):\n                print(f\u0026quot;Variable {variable.split('.')[1]} is not defined.\u0026quot;)\n        else:\n            print(\u0026quot;Import file does not exist.\u0026quot;)\n    else:\n        print(f\u0026quot;Variable type {variable.split('.')[0]} is not imported.\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edef get_actual_file_path(import_path, script_directory):\nif import_path.startswith(\u0026rsquo;@shared/\u0026rsquo;):\nreturn os.path.join(script_directory, import_path.replace(\u0026rsquo;@shared/\u0026rsquo;, \u0026lsquo;shared/\u0026rsquo;))\nelif import_path.startswith(\u0026rsquo;@doc-shared/\u0026rsquo;):\nreturn os.path.join(script_directory, \u0026lsquo;docs/shared\u0026rsquo;, import_path.replace(\u0026rsquo;@doc-shared/\u0026rsquo;, \u0026lsquo;\u0026rsquo;))\nelif import_path.startswith(\u0026rsquo;@api-shared/\u0026rsquo;):\nreturn os.path.join(script_directory, \u0026lsquo;docs-api-reference/shared\u0026rsquo;, import_path.replace(\u0026rsquo;@api-shared/\u0026rsquo;, \u0026lsquo;\u0026rsquo;))\nelse:\nprint(f\u0026quot;{import_path} File path is incorrect\u0026quot;)\nreturn None\u003c/p\u003e\n\u003cp\u003efile_a_path = \u0026lsquo;/your/file/path\u0026rsquo;  # Set the correct file path\u003c/p\u003e\n\u003cp\u003echeck_tag_pairs(file_a_path)\ncheck_quotes(file_a_path)\nsearch_variable_usage(file_a_path)\n\u003c/code\u003e\n\u003c/pre\u003e\u003c/p\u003e\n\u003c/details\u003e\n","description":null,"image":null,"permalink":"https://miumiu-op.github.io/blogs/sample2-script/","title":"Python Script for Writers"}]